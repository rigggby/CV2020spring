# -*- coding: utf-8 -*-
"""cv_hw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pKOiR8_lbx5oIq0LSj9irjDjF1p3YMYf
"""


import numpy as np
import cv2
import glob
import matplotlib.pyplot as plt
import camera_calibration_show_extrinsics as show
from PIL import Image
# prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
# (8,6) is for the given testing images.
# If you use the another data (e.g. pictures you take by your smartphone),
# you need to set the corresponding numbers.
corner_x = 7
corner_y = 7
objp = np.zeros((corner_x*corner_y,3), np.float32)
objp[:,:2] = np.mgrid[0:corner_x, 0:corner_y].T.reshape(-1,2)

# Arrays to store object points and image points from all the images.
objpoints = [] # 3d points in real world space
imgpoints = [] # 2d points in image plane.

# Make a list of calibration images
images = glob.glob('00'+'*.jpg')

# Step through the list and search for chessboard corners
print('Start finding chessboard corners...')
for idx, fname in enumerate(images):
    img = cv2.imread(fname)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    plt.imshow(gray)

    #Find the chessboard corners
    print('find the chessboard corners of',fname)
    ret, corners = cv2.findChessboardCorners(gray, (corner_x,corner_y), None)

    # If found, add object points, image points
    if ret == True:
        objpoints.append(objp)
        imgpoints.append(corners)

        # Draw and display the corners
        cv2.drawChessboardCorners(img, (corner_x,corner_y), corners, ret)
        # plt.figure()
        plt.imshow(img)


#######################################################################################################
#                                Homework 1 Camera Calibration                                        #
#               You need to implement camera calibration(02-camera p.76-80) here.                     #
#   DO NOT use the function directly, you need to write your own calibration function from scratch.   #
#                                          H I N T                                                    #
#                        1.Use the points in each images to find Hi                                   #
#                        2.Use Hi to find out the intrinsic matrix K                                  #
#                        3.Find out the extrensics matrix of each images.                             #
#######################################################################################################

from scipy.spatial.transform import Rotation as R
from scipy import optimize as opt


def cost(homography,objp,imgp):
    #[objp,imgp]=pts
    Y = []
    #print("hom:{}".format(homography))
    for i in range(0, len(objp)):
        x = objp[i][0]
        y = objp[i][1]
        w = homography[6] * x + homography[7] * y + homography[8]
        M = np.array([
            [homography[0], homography[1], homography[2]],
            [homography[3], homography[4], homography[5]]
        ])
        h = np.transpose(np.array([x, y, 1]))
        [u, v] = (1/w)*np.dot(M, h)
        #if i<5:
        #  print(abs(u-imgp[i][0][0]))
        #  print(abs(v-imgp[i][0][1]))

        Y.append(abs(u-imgp[i][0][0]))
        Y.append(abs(v-imgp[i][0][1]))
        #Y.append(u)
        #Y.append(v)

    return np.array(Y)

def jac(homography, objp,imgp):
    J = []
    for i in range(0, len(objp)):
        x = objp[i][0]
        y = objp[i][1]
        s_x = homography[0] * x + homography[1] * y + homography[2]
        s_y = homography[3] * x + homography[4] * y + homography[5]
        w = homography[6] * x + homography[7] * y + homography[8]
        J.append(np.array([x / w, y / w, 1/w,0, 0, 0,(-s_x * x) / (w*w), (-s_x * y) / (w*w), -s_x / (w*w)]))
        J.append(np.array([0, 0, 0,x / w, y / w, 1 / w,(-s_y * x) / (w*w), (-s_y * y) / (w*w), -s_y / (w*w)]))

    return np.array(J)

def normalization(i):
    i=i.reshape(49,-1)
    avg_x = i[..., 0].mean()
    avg_y = i[..., 1].mean()
    s_x = np.sqrt(2 / i[...,0].std())
    s_y = np.sqrt(2 / i[...,1].std())#std
    return np.matrix([
        [s_x,0, -s_x * avg_x],
        [0, s_y,-s_y * avg_y],
        [0,0,1]])


def get_H_opt(objpoints, imgpoints):
    image_n = len(objpoints)
    H = []
    X = []
    for i in range(image_n):
        # H (objpoints) = imgpoints
        # expand the eauations and we can obtain a system Ax = b
        # find x to min norm (Ax - b)
        # x = h1, h2, ... h9
        point_n = len(objpoints[i])
        obj_array = np.zeros((point_n*3, 9))
        b = np.zeros(point_n*3)
        objp_norm=normalization(np.array(objpoints[i]))
        imgp_norm=normalization(np.array(imgpoints[i]))
        #print(objp_norm)
        for j in range(point_n):
            objp_ori = objpoints[i][j]#change third column to 1
            imgp_ori =  np.append(imgpoints[i][j][0],1.)
            objp=np.array(np.dot(objp_norm,objp_ori))[0]
            #print(np.shape(objp))
            #objp=objp+np.array([[objp_norm[0][2]],[objp_norm[1][2]],[objp_norm[2][2]]])
            """objp[0]-=3
            objp[1]-=3
            objp[2]+=1"""
            imgp=np.array(np.dot(imgp_norm,imgp_ori))[0]
            j = j*3
            obj_array[j, 0] = -objp[0]
            obj_array[j, 1] = -objp[1]
            obj_array[j, 2] = -1
            obj_array[j, 6] = objp[0] * imgp[0]
            obj_array[j, 7] = objp[1] * imgp[0]
            obj_array[j, 8] = imgp[0]

            obj_array[j+1, 3] = -objp[0]
            obj_array[j+1, 4] = -objp[1]
            obj_array[j+1, 5] = -1
            obj_array[j+1, 6] = objp[0] * imgp[1]
            obj_array[j+1, 7] = objp[1] * imgp[1]
            obj_array[j+1, 8] = imgp[1]

            obj_array[j+2, 6] = objp[0]
            obj_array[j+2, 7] = objp[1]
            obj_array[j+2, 8] = 1
            b[j+2] = 1

        x = np.linalg.pinv(obj_array) @ b
        h = x.reshape(3, 3)
        denormalised = np.dot(np.dot(np.linalg.inv(imgp_norm),h),objp_norm)
        denormalised=denormalised/denormalised[-1,-1]
        denormalised=np.squeeze(np.asarray(denormalised))
        denormalised=denormalised.reshape(9,)
        #print(type(denormalised))
        #print(np.shape(denormalised))
        refined=opt.least_squares(cost,denormalised,jac=jac,args=(objpoints[i],imgpoints[i]),method='lm').x
        #refined=opt.root(cost,denormalised,jac=jac,args=(objpoints[i],imgpoints[i]),method='lm').x
        refined=refined/refined[-1]
        H.append(refined.reshape(3,3))
        #H.append(denormalised/denormalised[-1,-1])
    return H

def get_H_numerical(objpoints, imgpoints):
    image_n = len(objpoints)
    H = []
    X = []
    for i in range(image_n):
        # H (objpoints) = imgpoints
        # expand the eauations and we can obtain a system Ax = b
        # find x to min norm (Ax - b)
        # x = h1, h2, ... h9
        point_n = len(objpoints[i])
        obj_array = np.zeros((point_n*3, 9))
        b = np.zeros(point_n*3)
        for j in range(point_n):
            objp = objpoints[i][j]
            imgp =  imgpoints[i][j][0]
            j = j*3
            obj_array[j, 0] = -objp[0]
            obj_array[j, 1] = -objp[1]
            obj_array[j, 2] = -1
            obj_array[j, 6] = objp[0] * imgp[0]
            obj_array[j, 7] = objp[1] * imgp[0]
            obj_array[j, 8] = imgp[0]

            obj_array[j+1, 3] = -objp[0]
            obj_array[j+1, 4] = -objp[1]
            obj_array[j+1, 5] = -1
            obj_array[j+1, 6] = objp[0] * imgp[1]
            obj_array[j+1, 7] = objp[1] * imgp[1]
            obj_array[j+1, 8] = imgp[1]

            obj_array[j+2, 6] = objp[0]
            obj_array[j+2, 7] = objp[1]
            obj_array[j+2, 8] = 1
            b[j+2] = 1

        x = np.linalg.pinv(obj_array) @ b
        h = x.reshape(3, 3)
        H.append(h)

    return H

def get_H_cross(objpoints, imgpoints):
    image_n = len(objpoints)
    H = []
    for i in range(image_n):
        point_n = len(objpoints[0])
        A = np.zeros((point_n*2, 9))
        for j in range(point_n):
            objp = objpoints[i][j]
            imgp = imgpoints[i][j][0]
            j = j*2
            A[j, 3] = -objp[0]
            A[j, 4] = -objp[1]
            A[j, 5] = -1
            A[j, 6] = objp[0]*imgp[1]
            A[j, 7] = objp[1]*imgp[1]
            A[j, 8] = imgp[1]
            A[j+1, 0] = objp[0]
            A[j+1, 1] = objp[1]
            A[j+1, 2] = 1
            A[j+1, 6] = -objp[0]*imgp[0]
            A[j+1, 7] = -objp[1]*imgp[0]
            A[j+1, 8] = -imgp[0]

        u, s, v = np.linalg.svd(A)
        v = v[:,8]
        H.append(v.reshape((3, 3)))
    return H

def get_H(objpoints, imgpoints):
    image_n = len(objpoints)
    H = []
    X = []
    for i in range(image_n):
        # H (objpoints) = imgpoints
        # expand the eauations and we can obtain a system Ax = b
        # find x to min norm (Ax - b)
        # x = h1, h2, ... h9
        point_n = len(objpoints[i])
        obj_array = np.zeros((point_n*3, 9))
        b = np.zeros(point_n*3)
        for j in range(point_n):
            objp = objpoints[i][j]
            imgp =  imgpoints[i][j][0]
            j = j*3
            obj_array[j, 0] = -objp[0]
            obj_array[j, 1] = -objp[1]
            obj_array[j, 2] = -1
            obj_array[j, 6] = objp[0] * imgp[0]
            obj_array[j, 7] = objp[1] * imgp[0]
            obj_array[j, 8] = imgp[0]

            obj_array[j+1, 3] = -objp[0]
            obj_array[j+1, 4] = -objp[1]
            obj_array[j+1, 5] = -1
            obj_array[j+1, 6] = objp[0] * imgp[1]
            obj_array[j+1, 7] = objp[1] * imgp[1]
            obj_array[j+1, 8] = imgp[1]

            obj_array[j+2, 6] = objp[0]
            obj_array[j+2, 7] = objp[1]
            obj_array[j+2, 8] = 1
            b[j+2] = 1

        x = np.linalg.pinv(obj_array) @ b
        #x=x/x[-1]
        h = x.reshape(3, 3)
        #print("h:{}".format(h))
        refined=opt.root(cost,x,jac=jac,args=(objpoints[i],imgpoints[i]),method='lm').x
        #print(np.shape(x))
        #refined=opt.least_squares(cost,x,jac=jac,args=(objpoints[i],imgpoints[i]),method='lm').x
        refined=refined/refined[-1]
        H.append(refined.reshape(3,3))
        #H.append(h)

    return H

def get_B(H):
    # sol: Ax = b x = inv(A)*b
    # assume there are H_n H matrics, the size of A is 3n*6, b is 6*1
    A = np.zeros((len(H)*3, 6))
    b = np.zeros(len(H)*3)
    for i, h in enumerate(H):
        i = i*3
        A[i, 0] = h[0, 0] * h[0, 1]
        A[i, 1] = h[1, 0] * h[0, 1] + h[0, 0] * h[1, 1]
        A[i, 2] = h[2, 0] * h[0, 1] + h[0, 0] * h[2, 1]
        A[i, 3] = h[1, 0] * h[1, 1]
        A[i, 4] = h[2, 0] * h[1, 1] + h[1, 0] * h[2, 1]
        A[i, 5] = h[2, 0] * h[2, 1]
        b[i] = 0

        A[i+1, 0] = h[0, 0] * h[0, 0]
        A[i+1, 1] = 2 * h[0, 0] * h[1, 0]
        A[i+1, 2] = 2 * h[0, 0] * h[2, 0]
        A[i+1, 3] = h[1, 0] * h[1, 0]
        A[i+1, 4] = 2 * h[0, 0] * h[2, 0]
        A[i+1, 5] = h[2, 0] * h[2, 0]
        b[i+1] = 1

        A[i+2, 0] = h[0, 1] * h[0, 1]
        A[i+2, 1] = 2 * h[0, 1] * h[1, 1]
        A[i+2, 2] = 2 * h[0, 1] * h[2, 1]
        A[i+2, 3] = h[1, 1] * h[1, 1]
        A[i+2, 4] = 2 * h[0, 1] * h[2, 1]
        A[i+2, 5] = h[2, 1] * h[2, 1]
        b[i+2] = 1


    q, r = np.linalg.qr(A)
    B = np.linalg.pinv(A) @ b

    B_matrix = np.zeros((3, 3))
    B_matrix[0, 0] = B[0]
    B_matrix[0, 1] = B[1]
    B_matrix[1, 0] = B[1]
    B_matrix[0, 2] = B[2]
    B_matrix[2, 0] = B[2]
    B_matrix[1, 1] = B[3]
    B_matrix[1, 2] = B[4]
    B_matrix[2, 1] = B[4]
    B_matrix[2, 2] = B[5]
    return B_matrix

def get_RT(H, B):
    RT = []
    for h in H:
        rt = np.zeros((3, 4))
        L = np.linalg.cholesky(B)
        h=np.squeeze(np.asarray(h))#matrix to ndarray
        # inv k = L.T
        # K = np.linalg.inv(L.T)
        # print(np.linalg.norm(h[:, 1].T @ L @ L.T @ h[:, 1]))
        scale = 1 / np.linalg.norm(L.T @ h[:, 0])
        rt[:, 0] = L.T @ h[:, 0] * scale
        rt[:, 1] = L.T @ h[:, 1] * scale
        rt[:, 2] = np.cross(rt[:, 0], rt[:, 1])
        rt[:, 3] = scale * L.T @ h[:, 2]
        RT.append(rt)
    return RT

def get_K(H, B):
    L = np.linalg.cholesky(B)
    K = np.linalg.inv(L.T)
    K = K/K[2,2]
    """v0=(B[0][1]*B[0][2]-B[0][0]*B[1][2])/(B[0][0]*B[1][1]-B[0][1]*B[0][1])
    l=B[2][2]-(B[0][2]*B[0][2]+v0*(B[0][1]*B[0][2]-B[0][0]*B[1][2]))/B[0][0]
    alpha=np.sqrt(l/B[0][0])
    beta=np.sqrt(l*B[0][0]/(B[0][0]*B[1][1]-B[0][1]*B[0][1]))
    gamma=-B[0][1]*alpha*alpha*beta/l
    u0=gamma*v0/beta-B[0][2]*alpha*alpha/l
    K=np.array([[alpha,0,u0],[0,beta,v0],[0,0,1]])
    #print(K)"""
    return K

def calibrateCamera(objpoints, imgpoints):
    H = get_H_opt(objpoints, imgpoints)
    B = get_B(H)
    K = get_K(H, B)
    RT = get_RT(H, B)
    return H, B, K, RT

def ext_transfer(extrinsics):
    R_cal = []
    T_cal = []
    for ext in extrinsics:
        r = R.from_dcm(ext[:, :3])
        r = r.as_rotvec()
        t = ext[:, 3].flatten()
        R_cal.append(r)
        T_cal.append(t)
    R_cal = np.asarray(R_cal)
    T_cal = np.asarray(T_cal)

    extrinsics_cal = np.concatenate((R_cal, T_cal), axis=1).reshape(-1,6)
    return extrinsics_cal

print("Our Camera calibration...")
H, B, K, RT = calibrateCamera(objpoints, imgpoints)
intrinsic = K
print("intrinsic:{}".format(K))
extrinsics = RT
extrinsics_cal = ext_transfer(extrinsics)
print("extrinsic:{}".format(extrinsics_cal))


print('OpenCV Camera calibration...')
img_size = (img.shape[1], img.shape[0])
# You need to comment these functions and write your calibration function from scratch.
# Notice that rvecs is rotation vector, not the rotation matrix, and tvecs is translation vector.
# In practice, you'll derive extrinsics matrixes directly. The shape must be [pts_num,3,4], and use them to plot.

ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, img_size,None,None)
Vr = np.array(rvecs)
Tr = np.array(tvecs)
extrinsics = np.concatenate((Vr, Tr), axis=1).reshape(-1,6)

# mtx: cameramatrix
print("intrinsic:{}".format(mtx))
print("distortion coefficient:{}".format(dist))
print("extrinsic:{}".format(extrinsics))

from scipy.spatial.transform import Rotation as R

BB = np.linalg.inv(mtx.T) @ np.linalg.inv(mtx)
HH = []
RTRT = []
for rvec in rvecs:
    r = R.from_rotvec(rvec.flatten())
    r = r.as_matrix()
    rtrt = np.zeros((3, 3))
    rtrt[:, :2] = r[:, :2]
    rtrt[:, 2] = Tr[0].reshape(3)
    RTRT.append(rtrt)
    hh = mtx@rtrt
    HH.append(hh)

# show the camera extrinsics
print('Show the camera extrinsics')
# plot setting
# You can modify it for better visualization
fig = plt.figure(figsize=(10, 10))
ax = fig.gca(projection='3d')
# camera setting
camera_matrix = intrinsic
cam_width = 0.064/0.1
cam_height = 0.032/0.1
scale_focal = 1600
# chess board setting
board_width = 8
board_height = 6
square_size = 1
# display
# True -> fix board, moving cameras
# False -> fix camera, moving boards
min_values, max_values = show.draw_camera_boards(ax, camera_matrix, cam_width, cam_height,
                                                scale_focal, extrinsics_cal, board_width,
                                                board_height, square_size, True)

X_min = min_values[0]
X_max = max_values[0]
Y_min = min_values[1]
Y_max = max_values[1]
Z_min = min_values[2]
Z_max = max_values[2]
max_range = np.array([X_max-X_min, Y_max-Y_min, Z_max-Z_min]).max() / 2.0

mid_x = (X_max+X_min) * 0.5
mid_y = (Y_max+Y_min) * 0.5
mid_z = (Z_max+Z_min) * 0.5
ax.set_xlim(mid_x - max_range, mid_x + max_range)
ax.set_ylim(mid_y - max_range, 0)
ax.set_zlim(mid_z - max_range, mid_z + max_range)

ax.set_xlabel('x')
ax.set_ylabel('z')
ax.set_zlabel('-y')
ax.set_title('Extrinsic Parameters Visualization')
plt.show()

#animation for rotating plot
"""
for angle in range(0, 360):
    ax.view_init(30, angle)
    plt.draw()
    plt.pause(.001)
"""
